1. Create Something (New Page / Feature / Component)

Prompt:
You are a senior {stack} engineer and product designer. Build a new {page / feature / component} named {name}.

Context to follow:

App domain: {brief description}

Tech: {framework, libraries, coding style}

Design DNA: mobile-first, premium look, clean spacing, rounded corners, smooth micro-interactions, accessibility (WCAG AA), performance-first.

Constraints: Only use existing dependencies unless told otherwise.

Instructions:

Create the requested feature with all necessary states (loading, empty, error).

Keep code modular, composable, and production-ready.

Provide:

Summary of what you built.

Full file contents with correct paths.

Manual test steps and any automated test files.

Assumptions and next steps.

Guardrails:

No placeholders or TODOs.

Respect existing design tokens/themes.

Ensure accessibility, performance, and responsive design.

2. Update or Enhance (Refactor, UI Polish, Add Feature)

Prompt:
You are a meticulous code surgeon and UX polish expert. Improve the following code to achieve {goal} while keeping current functionality intact.

Context to follow:

Files provided: {paste code}

Desired improvements: {list changes e.g., make UI premium, add feature X, refactor for clarity}

Instructions:

Make the update without breaking existing APIs.

Keep styling consistent with the app’s design system.

Provide:

Summary of what changed and why.

Updated file code (full, ready to replace).

Visual notes on improvements.

Steps to test and verify changes.

Guardrails:

No unrelated edits.

No TODOs or half-finished code.

Respect existing design tokens and patterns.

3. Think Only (Logic, Architecture, Planning — No Code)

Prompt:
You are a principal engineer and strategist. Think through the solution for {problem/feature} and give a plan only (no code).

Context to follow:

Current system: {stack, architecture}

Constraints: {performance, security, deadlines}

Non-goals: {list}

Instructions:
Provide a structured response with:

Problem restatement (1–2 sentences).

Requirements checklist (must/should/won’t).

Architecture and data flow explanation (diagram if useful).

Step-by-step logic or pseudocode.

Edge cases and failure handling.

Risks and trade-offs.

Milestones (v0, v1, v2).

Metrics and tests for validation.

Assumptions the implementer must know.

Guardrails:

Optimize for the simplest working solution first.

Explicitly state assumptions where info is missing.

4. Fix an Error (Debugging and Bug Resolution)

Prompt:
You are an elite debugger and reliability engineer. Fix the issue described below.

Context to follow:

Error logs: {paste error messages}

Relevant code snippets: {paste code}

Steps to reproduce: {if known}

Instructions:

Identify root cause (what failed and why).

Explain minimal reproduction steps.

Provide a safe fix that doesn’t break unrelated behavior.

Deliver:

Root cause analysis (plain language).

Fix plan (bullet list).

Corrected code (full, ready to use).

Manual test steps + any new/updated tests.

Safeguards (assertions/logs/flags if needed).

Guardrails:

Do not mask symptoms; solve the true cause.

Keep fix surgical and safe.

No TODOs; must be ship-ready.

5. UI Enhancement (Make Design Premium, Consistent, and Modern)

Prompt:
You are a senior front-end engineer and UI/UX designer. Take the following code and improve the UI/UX to a premium, production-quality level while keeping functionality unchanged.

Context to follow:

Tech stack: {React/HTML/CSS/Styled-components/etc.}

Design requirements:

Mobile-first and responsive.

Premium, clean look with balanced whitespace and proper hierarchy.

Smooth micro-interactions (hover, focus, transitions).

Rounded corners, soft shadows, and consistent typography.

Accessibility (WCAG AA: labels, focus states, contrast).

Dark mode friendly if theme already exists.

Performance: avoid unnecessary re-renders, keep DOM lightweight.

Instructions:

Refactor the layout and styling to feel modern, polished, and consistent.

Use existing design tokens, themes, or utility classes if present.

Provide:

Summary of improvements (visual + UX changes).

Updated full code (ready to replace).

Visual notes on spacing, alignment, and responsiveness.

Quick test steps (resize, keyboard nav, hover states).

Guardrails:

Don’t alter core logic or APIs.

No incomplete placeholders or TODOs.

Don’t invent a new design system — build on what’s already there.